# -*- coding: utf-8 -*-
"""Algoritmos-geneticos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vHzZTiyVrhDw5ocKc717qv0tqywuggL8

Se genera una cadena de bits

> el primer valor es el que queremos convertir a cadena de bits
"""

cadena = format(30, f"0{5}b")
print(cadena)

"""Algoritmo"""

from random import randint, random


def generarPoblacion(cantInd):
    poblacion = []
    for i in range(cantInd):
        # se agregan los individuos
        poblacion.append(format(randint(0, 31), f"0{5}b"))
    return poblacion


def evaluarPoblacion(poblacion):
    # decodificar
    fitness = []
    # recorro la población
    for ind in poblacion:
        # obtengo el fitness del individuo y ahí mismo evalúo en la función f(x)=x^2
        fitness.append(int(ind, 2) ** 2)
    return fitness


def Seleccion(poblacion, fitness):
    nuevaPob = []
    # se elige al mejor por elitismo
    # se agrega a la población el que tiene el fitness más alto
    indice = fitness.index(max(fitness))
    nuevaPob.append(poblacion[indice])
    # seleccionamos al resto de individuos por torneo
    for i in range(3):
        ind1 = randint(0, 3)
        ind2 = randint(0, 3)
        # que no salga una pareja del mismo individuo
        while ind1 == ind2:
            # si es el mismo, volvemos a generar otro aleatorio
            ind2 = randint(0, 3)
        # aplicamos torneo determinista
        # elegimos al que tiene mayor fitness
        if fitness[ind1] > fitness[ind2]:
            nuevaPob.append(poblacion[ind1])
        else:
            nuevaPob.append(poblacion[ind2])
    return nuevaPob


def Rangos(poblacion, fitness):
    nuevaPob = []
    # ordenamos de manera ascendente porque se maximiza con burbuja
    n = len(fitness)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if fitness[j] > fitness[j + 1]:
                aux = fitness[j]
                fitness[j] = fitness[j + 1]
                fitness[j + 1] = aux

                Paux = poblacion[j]
                poblacion[j] = poblacion[j + 1]
                poblacion[j + 1] = aux
    # asignamos el ranking
    rankings = []
    for f in fitness:
        rankings.append(f + 1)
    # sumamos los rankings
    total = sum(rankings)
    # asignamos una probabilidad a cada individuo
    probabilidad = []
    for r in rankings:
        probabilidad.append(r / total)
    # lanzamos el aleatorio
    aleatorio = random()
    # evaluamos en que rango cae
    for x in probabilidad:
        if aleatorio <= probabilidad[0]:
            nuevaPob.append(poblacion[0])
        elif probabilidad[0] < aleatorio <= (probabilidad[0] + probabilidad[1]):
            nuevaPob.append(poblacion[1])
        elif probabilidad[1] < aleatorio <= (probabilidad[1] + probabilidad[2]):
            nuevaPob.append(poblacion[2])
        else:
            nuevaPob.append(poblacion[3])
    return nuevaPob


def Cruza(poblacion: list[str]):
    nuevaPob = []
    for i in range(2):
        padre1 = randint(0, 3)
        padre2 = randint(0, 3)
        while padre1 == padre2:
            padre2 = randint(0, 3)
        puntoCruce = randint(1, 4)
        hijo1 = poblacion[padre1][:puntoCruce] + poblacion[padre2][puntoCruce:]
        hijo2 = poblacion[padre2][:puntoCruce] + poblacion[padre1][puntoCruce:]
        nuevaPob.append(hijo1)
        nuevaPob.append(hijo2)
    return nuevaPob


def Muta(poblacion):
    nuevaPob = []
    for i in range(len(poblacion)):
        # se forza a ser una lista porque las cadenas son inmutables en python
        individuo = list(poblacion[i])
        # se evalua si muta o no el individuo
        if random() <= 0.1:
            alelo = randint(0, 4)
            if individuo[alelo] == "0":
                individuo[alelo] == "1"
            else:
                individuo[alelo] = "0"
        # se regresa a ser cadena
        individuo = "".join(individuo)
        nuevaPob.append(individuo)
    return nuevaPob


def evaluacion(fitness):
    for fit in fitness:
        if fit == 961:
            return True
    return False


# PASO 1: Generar una población aleatoria de 4 individuos
poblacion = []
poblacion = generarPoblacion(4)
# PASO 2: Evaluar fitness
fitness = evaluarPoblacion(poblacion)
print(poblacion)
print(fitness)
paro = False
generacion = 0
while (paro != True) and (generacion <= 30):
    # Seleccionar a los mejores individuos según su fitness, aplicar elitismo para el primer individuo, y torneo determinista para el resto de individuos
    poblacion = Rangos(poblacion, fitness)
    # Cruza de un solo punto, generación de dos hijos por pareja.
    poblacion = Cruza(poblacion)
    poblacion = Muta(poblacion)
    # muta de un solo gen con prob. 0.1 - 10%
    fitness = evaluarPoblacion(poblacion)
    print(poblacion)
    print(fitness)
    paro = evaluacion(fitness)
    generacion = generacion + 1

